<html>
<head>
<title>yads: principles</title>
<style type='text/css'>
<!--
  body { background-color: white }
  body { color: black }
  body { font-family: arial, helvetica, sans-serif }
  body { font-size: 12pt }
  h1 { color: slateblue }
  h1 { font-size: 22pt }
  h3 { color: slateblue }
  h1 { font-family: arial, helvetica, sans-serif }
  p { font-family: arial, helvetica, sans-serif }
  td { font-family: arial, helvetica, sans-serif }
  hr { font-family: arial, helvetica, sans-serif }
-->
</style>
</head>
<body>
<center>
<table width=90% border=0>
<tr>
<td>
<table width=100% border=0>
<tr>
<td>
<h1><i>yads: DObject Model Principles</i></h1>
<hr>
In order to support resolution of a DOI to multiple resources we make use of the following
principles:
<dl>
<dt><b>Resources</b>
<dd>Resources in the context of the DObject Model are either:
<ul>
<li>"<i>Literals</i>" (<code>rdf:resource</code>, mapping 1:1) - inline resources identified by URI of
scheme "data:" (RFC 2397), ie literals are represented as resources.
<li>"<i>Resources</i>" (<code>rdf:resource</code>, mapping 1:1) - familiar web resources identified by URI; properties: anonymous, maintained by a single organization or enterprise.
<li>"<i>DObjects</i>" (<code>rdf:resource</code>, mapping 1:N) - managed resources identified by URI of scheme
 "doi:" (the DOI); properties: named, maintained across a common business sector.
</ul>
<dt><b>Hierarchy</b>
<dd>There is a clear need to organize resources - by grouping, by hierarchy, by ordering.
<dt><b>Type Primitives</b>
<dd>Resources are typed against a limited set of primitive data types - see <a href="schema.html">RDFS Schema</a>
<dt><b>Resource Map</b>
<dd>A simple resource map construct allows for a resource hierarchy to be reposited in a flat DataStore.
This Resource Map serves as a simple driver to generate a resource hierarchy serialization, eg an RDF/XML instance.
<dt><b>Transfer Syntax</b>
<dd>The DObject resource description is serialized as an XML document. In particular an RDF/XML serialization provides the necessary constraints. This is purely an "under the hood" exchange syntax which is not intended to be exposed to DOI end 
users, although it does allow for downstream interop with other RDF aware applications.
The DOI <a href="services.html">Client/Service</a> interop stack is defined for both distributed and 
localized implementations.
<dt><b>Neutral Semantics</b>
<dd>The semantics that are to be exchanged between a DOI client application and a DOI service are primarily structural.
The client/service transactions are effectively dealing with a type of "Poorboy RDF".
<dt><b>Late Binding</b>
<dd>An extensibility type mechanism is provided through the type "<code>doi:type</code>". As an example consider how a 
new eBook format type could be introduced:
<p>
<table width=90% border=1 cellpadding=5 bgcolor=#dddddd>
<tr>
<td>
<pre><code>
&lt;rdf:li rdf:parseType="Resource"&gt;
  &lt;doi:resource&gt;data:Microsoft+Reader&lt;/doi:resource&gt;
  &lt;doi:type&gt;xyz:ebook_format&lt;/doi:type&gt;
&lt;/rdf:li&gt;
</code></pre>
</td>
</tr>
</table>
<p>
Application specific semantics are recovered from an Application specific schema which is registered with the 
DOI Application Profile. This mechanism allows the generic RDF for a DOI to be specialized (or enriched) into an Application specific RDF:
<p>
<table width=90% border=1 cellpadding=5 bgcolor=#dddddd>
<tr>
<td>
<pre><code>
&lt;rdf:li rdf:parseType="Resource"&gt;
  &lt;xyz:ebook_format&gt;Microsoft Reader&lt;/doi:literal&gt;
&lt;/rdf:li&gt;
</code></pre>
</td>
</tr>
</table>
</dl>
</td>
</tr>
</table>
<table width=100% border=0>
<tr>
<td>
<hr>
<a href="mailto:tony_hammond@harcourt.com">Mailto</a>
<br>
</td>
</tr>
</table>
</td>
</tr>
</table>
</center>
</body>
</html>
