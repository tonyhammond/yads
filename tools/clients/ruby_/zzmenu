#!/home/tony/bin/ruby

require 'dataObject'

require 'cgi'

cgi = CGI.new
hParams = cgi.params		# CGI parameter hash

$debug = 0
$debug += ARGV[1].to_i

if hParams.has_key?('doi')

  doi = hParams['doi'][0]

else
 
  doi = ARGV[0]
end

  print "content-type: text/html\n\n"

class DataObject

  def to_menus

tmp = 0
    depth = 0
    aProps = []
    props = []
    stack = [ [ depth, props ] ]
    offset = 1
    item = 0
container = 0
    menus = Array.new(@dataMap.length, 0); menus[1] = 1
    menuKey = ""

    hMenus = {} 
    aMenu = []

    @dataMap.scan(/\S+/).each do |s|

      case s

 
        when "{", "[", "<"
p stack if $debug > 2
container += 1
          item = 0
	
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n" if $debug > 1
          print "\"#{s}\": ", menus[1..offset].join("_"), "\n" if $debug > 0

          menuKey = menus[1..offset].join("_")

          # (depth, props) = stack[-1]

=begin
          if hMenus.key?(menuKey) and not hMenus[menuKey].empty?
            aProps.clear
            hMenus[menuKey].each { |a| aProps << a }
# p props; p aProps
            props << aProps
          end
=end
# print "<<\n"
# puts props
          props << ["contains", "<i>rdf:Bag #{container}</i>"] if s == "{"
          props << ["contains", "<i>rdf:Seq</i>"] if s == "["
          props << ["contains", "<i>rdf:Alt</i>"] if s == "<"
          hMenus[menuKey] = props
# print ">>\n"
# puts props

          offset += 1; depth += 1; props = []; stack << [ depth, props ]
          # menus[offset+1] = depth;

          # menuKey = menus[1..offset].join("_")
          # hMenus[menuKey] = props
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n\n" if $debug > 1

        when "}", "]", ">"
p stack if $debug > 2
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n" if $debug > 1

          (depth, props) = stack[-1]; stack.pop;offset -= 1; 
          (tmp, props) = stack[-1];
          #  stack.pop;(depth, props) = stack[-1]; offset -= 1;
          
          print "\"#{s}\": ", menus[1..offset].join("_"), "\n" if $debug > 0
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n\n" if $debug > 1

        when "("
p stack if $debug > 2

          item += 1

          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n" if $debug > 1
          menus[offset] = depth; depth = 0; props = []

          print "\"#{s}\": ", menus[1..offset].join("_"), "\n" if $debug > 0

          menuKey = menus[1..offset].join("_")

          hMenus[menuKey].each { |a| props << a } \
            if hMenus.key?(menuKey) and not hMenus[menuKey].empty?

          props << ["dataGroup", "<i>rdf:_#{item}</i>"]
          hMenus[menuKey] = props

          # offset += 1; menus[offset] += 1; props = []; stack << [ depth, props ]
          offset += 1; menus[offset] = 1; props = []; stack << [ depth, props ]

          menuKey = menus[1..offset].join("_")
          hMenus[menuKey] = props
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n\n" if $debug > 1

        when ")"
p stack if $debug > 2
          
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n" if $debug > 1
          print "\"#{s}\": ", menus[1..offset].join("_"), "\n" if $debug > 0
          
          menuKey = menus[1..offset].join("_")
          (depth, props) = stack[-1]
          hMenus[menuKey] = props

          offset -= 1; stack.pop; # (depth, props) = stack[-1]
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n\n" if $debug > 1

        else
p stack if $debug > 2

          depth += 1

          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n" if $debug > 1
          print "\"#{s}\": ", menus[1..offset].join("_"), "\n" if $debug > 0
          # menus[offset+1] = depth;

          (type, data) = @dataObject[s.to_i]
          props << [type, data]
          print "\"#{s}\": ", menus[1..16].join("_"), " (o:#{offset},d:#{depth})\n\n" if $debug > 1

      end

    end

    hMenus.sort.each do |keyProps, valProps|

      # next if valProps.empty?
      print "arMenu#{keyProps} = new Array("
      print "200,\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"," if keyProps == "1"
      print "\n"

      valProps.each do |key, val|

        case key

          when /resource/
            aMenu << "\"<b>[#{key}]</b> #{val}\", \"#{val}\", 0"

          when /relation|profile/
            bare_doi = val.sub(/^doi:/, "")
            aMenu << "\"<b>[#{key}]</b> #{val}\", \"http://www2.harcourt-international.com/ap/servlet/yads?rtnType=menus&doi=#{bare_doi}\", 0"

          when /contains|dataGroup/
            aMenu << "\"<b>[#{key}]</b> #{val}\", \"\", 1"

          else
            aMenu << "\"<b>[#{key}]</b> \\\"#{val}\\\"\", \"\", 0"

        end

      end

      print aMenu.join(",\n"); aMenu.clear
      print "\n)\n\n"

    end
 
  end

end

if $debug > 0

  d = DataObject.get(doi).to_menus
=begin
  rdf = ""
  DATA.each_line { |line| rdf += line }
  d = DataObject.new(doi).from_s(rdf).to_menus
=end
  exit

else

    aFile = File.new("/opt/HARCap/servlets/doi/doi_menus.js")
    aFile.each { |line|
      line.sub!(/(tri.gif)/, "http://www2.harcourt-international.com/~tony/ruby/ruby/tri.gif")
      print line
    }

    print <<EOT

<SCRIPT LANGUAGE="JavaScript1.2" TYPE="text/javascript">
<!--
if (isMenu) {
EOT
    
d = DataObject.get(doi).to_menus

    print <<EOT
}
//--> </SCRIPT>
EOT


sLine = "<body>\n"
        sLine << "This is <a href="
        sLine << "\"javascript:void(0)\" "
        sLine << "onMouseOver=\"popUp(\'elMenu1\',event)\" "
        sLine << "onMouseOut=\"popDown(\'elMenu1\')\" "
        sLine << "onClick=\"return false\""
        sLine << ">doi:#{doi}</a> as a menu popup."

print sLine

end

__END__
<rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:doi="doi:1014/10.1000/system.schema.2001-07-26#"
>
<doi:Object rdf:about="doi:1014/10.1000/system.profile.crossref">
  <doi:contains>
    <rdf:Bag>
      <rdf:li rdf:parseType="Resource">
        <doi:profile rdf:resource="doi:1014/10.1000/system.profile.system"/>
        <doi:contains>
          <rdf:Bag>
            <rdf:li rdf:parseType="Resource">
              <doi:label>CrossRef Profile</doi:label>
              <doi:detail>CrossRef profile - A DOI Application Profile for the CrossRef application which resolves journal article DOIs from bibliographic metadata queries.</doi:detail>
              <doi:contains>
                <rdf:Bag>
                  <rdf:li rdf:parseType="Resource">
                    <doi:relation rdf:resource="doi:1014/10.1000/system.registry.profiles"/>
                    <doi:role>parent</doi:role>
                  </rdf:li>
                </rdf:Bag>
              </doi:contains>
              <doi:contains>
                <rdf:Bag>
                  <rdf:li rdf:parseType="Resource">
                    <doi:label>Scholarly journal article</doi:label>
                    <doi:role>genre</doi:role>
                  </rdf:li>
                </rdf:Bag>
              </doi:contains>
              <doi:contains>
                <rdf:Bag>
                  <rdf:li rdf:parseType="Resource">
                    <doi:agent rdf:resource="doi:1014/10.1000/system.agent.pila"/>
                    <doi:contains>
                      <rdf:Bag>
                        <rdf:li rdf:parseType="Resource">
                          <doi:service rdf:resource="http://query.crossref.org/tony/xref.cgi"/>
                          <doi:schema rdf:resource="http://www.crossref.org/docs/doi_batch.dtd"/>
                          <doi:role>metadata</doi:role>
                        </rdf:li>
                      </rdf:Bag>
                    </doi:contains>
                  </rdf:li>
                </rdf:Bag>
              </doi:contains>
            </rdf:li>
          </rdf:Bag>
        </doi:contains>
      </rdf:li>
    </rdf:Bag>
  </doi:contains>
</doi:Object>
</rdf:RDF>
